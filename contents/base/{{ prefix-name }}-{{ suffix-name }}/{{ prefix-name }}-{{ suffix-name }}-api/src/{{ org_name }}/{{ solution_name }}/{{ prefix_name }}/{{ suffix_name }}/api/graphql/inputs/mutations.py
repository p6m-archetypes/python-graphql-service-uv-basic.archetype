"""
GraphQL input types for mutations.

This module contains Strawberry input types for creating and updating
{{ prefix_name }} entities through GraphQL mutations.
"""

from typing import Optional
import strawberry

# Import the original Pydantic models for validation reference
from {{ org_name }}.{{ solution_name }}.{{ prefix_name }}.{{ suffix_name }}.api.models import ExampleDto


@strawberry.input(description="Input for creating a new {{ prefix_name }}")
class Create{{ PrefixName }}Input:
    """
    Input type for creating a new {{ prefix_name }}.
    
    This input type captures all the required and optional fields
    needed to create a new {{ prefix_name }} entity. It mirrors the
    validation rules from the Pydantic ExampleDto model.
    """
    
    name: str = strawberry.field(
        description="Name of the {{ prefix_name }} (required, 1-255 characters)"
    )
    
    def to_example_dto(self) -> ExampleDto:
        """
        Convert this input to a Pydantic ExampleDto for processing.
        
        Returns:
            ExampleDto instance with the input data
        """
        return ExampleDto(
            id=None,  # ID will be generated by the system
            name=self.name
        )


@strawberry.input(description="Input for updating an existing {{ prefix_name }}")
class Update{{ PrefixName }}Input:
    """
    Input type for updating an existing {{ prefix_name }}.
    
    This input type allows partial updates to {{ prefix_name }} entities.
    All fields are optional except for validation constraints.
    """
    
    name: Optional[str] = strawberry.field(
        description="Updated name for the {{ prefix_name }} (1-255 characters)",
        default=None
    )
    
    def to_example_dto(self, existing_id: str) -> ExampleDto:
        """
        Convert this input to a Pydantic ExampleDto for processing.
        
        Args:
            existing_id: The ID of the {{ prefix_name }} being updated
            
        Returns:
            ExampleDto instance with the updated data
        """
        return ExampleDto(
            id=existing_id,
            name=self.name if self.name is not None else ""  # Will need existing data
        )
    
    def has_updates(self) -> bool:
        """
        Check if this input contains any actual updates.
        
        Returns:
            True if any field has been provided for update
        """
        return self.name is not None


@strawberry.input(description="Input for deleting a {{ prefix_name }}")
class Delete{{ PrefixName }}Input:
    """
    Input type for deleting a {{ prefix_name }}.
    
    This input type provides the identifier for the {{ prefix_name }}
    to be deleted, along with optional confirmation parameters.
    """
    
    id: strawberry.ID = strawberry.field(
        description="ID of the {{ prefix_name }} to delete"
    )
    
    confirm: bool = strawberry.field(
        description="Confirmation that the deletion is intentional",
        default=False
    )


# Batch operation inputs
@strawberry.input(description="Input for creating multiple {{ prefix_name }}s")
class CreateMultiple{{ PrefixName }}Input:
    """
    Input type for creating multiple {{ prefix_name }}s in a single operation.
    
    This allows for efficient batch creation of {{ prefix_name }} entities
    with proper validation for each item.
    """
    
    {{ prefix_name }}s: list[Create{{ PrefixName }}Input] = strawberry.field(
        description="List of {{ prefix_name }}s to create"
    )
    
    skip_validation_errors: bool = strawberry.field(
        description="Whether to skip items that fail validation instead of failing the entire operation",
        default=False
    )


@strawberry.input(description="Input for updating multiple {{ prefix_name }}s")
class UpdateMultiple{{ PrefixName }}Input:
    """
    Input type for updating multiple {{ prefix_name }}s in a single operation.
    """
    
    updates: list["{{ PrefixName }}UpdateItem"] = strawberry.field(
        description="List of {{ prefix_name }} updates to apply"
    )
    
    skip_validation_errors: bool = strawberry.field(
        description="Whether to skip items that fail validation instead of failing the entire operation",
        default=False
    )


@strawberry.input(description="Single update item for batch operations")
class {{ PrefixName }}UpdateItem:
    """
    Input type for a single {{ prefix_name }} update in a batch operation.
    """
    
    id: strawberry.ID = strawberry.field(
        description="ID of the {{ prefix_name }} to update"
    )
    
    data: Update{{ PrefixName }}Input = strawberry.field(
        description="The update data to apply"
    ) 